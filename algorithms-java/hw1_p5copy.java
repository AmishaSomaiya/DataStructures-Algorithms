package cse417;
import cse417.hw1_p4;


import java.util.Arrays;
import java.util.Random;
import java.text.DecimalFormat;




public class hw1_p5copy {
	
	public static void main(String[] args) {
		

		//STEP 1: Generate M and W via random permutations of preference lists
		//STEP 2: Preprocessing Step to have O(1) lookup of matched ms in w's preference list during algorithm processing
		//STEP 3: Run Gale Shapley Algorithm for M and W
		//STEP 4: Calculate MRank and WRank 
		//STEP 5: Calculate MGoodness and WGoodness for analysis
		
		//Test Case from HW1 P4
		//int[][] M = {{2, 1, 3, 0}, {0, 1, 3, 2}, {0, 1, 2, 3}, {0, 1, 2, 3}};
		//int[][] W = {{0, 2, 1, 3}, {2, 0, 3, 1}, {3, 2, 1, 0}, {2, 3, 1, 0}};
		
		DecimalFormat dec = new DecimalFormat("#0.0000");
		System.out.println("\t\tM Proposal\t\t\t W Proposal");
		System.out.println("Size \t"+ "MGoodness \t"+ "WGoodness"+ "\t MGoodness" + "\t WGoodness");
		for (int i = 1000 ; i<10001; i=i+500) {
			int[][] M = generateRandomPermutations(i);                      //STEP 1
			int[][] W = generateRandomPermutations(i);
			int[][] MReverse = hw1_p4.RevereseMatching(M);                  //STEP 2
			int[][] WReverse = hw1_p4.RevereseMatching(W);
			//M Proposal Implementation
			int[] outputM = hw1_p4.GaleShapleyAlgorithm(M, W, WReverse);	//STEP 3		
			double MGoodnessM = calculateGoodnessForM(MReverse, outputM);   //STEP 4,5
			double WGoodnessM = calculateGoodnessForW(WReverse, outputM);
			//W Proposal Implementation
			int[] outputW = hw1_p4.GaleShapleyAlgorithm(W, M, MReverse);    //STEP 3
			double WGoodnessW = calculateGoodnessForM(WReverse, outputW);   //STEP 4,5
			double MGoodnessW = calculateGoodnessForW(MReverse, outputW);
			System.out.println(M.length + "\t" + dec.format(MGoodnessM) + "\t\t" + dec.format(WGoodnessM) +
			"\t" + dec.format(MGoodnessW) + "\t" + dec.format(WGoodnessW));	
		}
			
		}


	
	//custom method to generate completely random preference lists for M and W
	//examples of instances generated by this method for size 4 and 5:
	//M = [[2, 1, 0, 3], [2, 3, 1, 0], [1, 2, 3, 0], [3, 0, 1, 2]]
	//W = [[1, 2, 0, 3], [0, 1, 3, 2], [2, 0, 3, 1], [2, 0, 3, 1]]
	//M = [[0, 3, 2, 4, 1], [2, 0, 1, 3, 4], [3, 0, 2, 4, 1], [4, 0, 3, 2, 1], [0, 3, 4, 2, 1]]
	//W = [[3, 2, 1, 0, 4], [3, 1, 2, 0, 4], [3, 1, 4, 0, 2], [2, 1, 3, 0, 4], [0, 4, 2, 1, 3]]
	public static int[][] generateRandomPermutations (int size) {		

		int[][] array = new int[size][size];		
		int[] checkRepeats = new int[size];		
		Random rand = new Random();
		int j;
		
		for(int i = 0; i<size; i++) {
			Arrays.fill(checkRepeats, -1);
			j=0;
			while(j<size) {
				int random = rand.nextInt(size);
				if (checkRepeats[random] == -1) {
					array[i][j] = random;
					checkRepeats[random] = 1;
					j++;
				}
			}	
		}				
		return array;
		
	}
	

	public static double calculateGoodnessForM (int[][] MReverse, int[] outputMatching) {
		int size = MReverse.length;
		double rankCurrent = 0.0, MRank = 0.0;
	
				
		for(int i = 0; i< outputMatching.length ; i++) {
			rankCurrent = MReverse[i][outputMatching[i]] + 1;		
				MRank += rankCurrent;	
		}	
		
		return MRank/size;
	 }
		

			
	public static double calculateGoodnessForW (int[][] WReverse, int[] outputMatching) {
		int size = WReverse.length;
		double rankCurrent = 0.0, WRank = 0.0; 
				
		for(int i = 0; i< outputMatching.length; i++) {
			rankCurrent = WReverse[outputMatching[i]][i] + 1;
			WRank += rankCurrent;
		}
		
		return WRank/size;	
	 }			
		
		
	
		
		
	}



